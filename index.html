<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyper Wing - Web Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #0f172a; user-select: none; }
        #root { width: 100%; height: 100%; }
        
        /* Custom crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 4px cyan;
        }
        .crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        .crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        @keyframes bounce-short {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        .animate-bounce-short {
            animation: bounce-short 1s infinite;
        }
    </style>
    
    <!-- Import Map for React and Three.js -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.161.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.102.0?external=react,react-dom,three,@react-three/fiber"
        }
    }
    </script>
    
    <!-- Babel for JSX compilation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useCallback, useEffect, useRef, useMemo } from 'react';
        import ReactDOM from 'react-dom/client';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { Stars } from '@react-three/drei';
        import * as THREE from 'three';

        // --- CONSTANTS ---
        const PLAYER_SENSITIVITY = 0.08;
        const PLAYER_MAX_X = 25;
        const PLAYER_MAX_Y = 18;
        const PLAYER_MIN_Y = 1;
        const BULLET_SPEED = 120;
        const BULLET_LIFETIME = 2000;
        const ENEMY_SPAWN_RATE_BASE = 1800;
        const ARENA_SIZE = 120;

        const COLORS = {
            sky: '#0f172a',
            ground: '#1e293b',
            enemyBasic: '#ef4444',
            enemyFast: '#f59e0b',
            enemyTank: '#3b82f6',
            player: '#FFFFFF',
            bullet: '#00ffff',
            star: '#ffffff',
        };

        // --- AUDIO SYSTEM ---
        const playSound = (type) => {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.connect(gain);
            gain.connect(ctx.destination);

            const now = ctx.currentTime;

            if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'explode') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'hit') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            }
        };

        // --- COMPONENTS ---

        const PlayerWeapon = ({ lastShot = 0 }) => {
            const { camera } = useThree();
            const gunRef = useRef(null);
            const flashRef = useRef(null);
            const [recoil, setRecoil] = useState(0);
            
            useEffect(() => {
                if (lastShot > 0) {
                    setRecoil(0.3);
                }
            }, [lastShot]);

            useFrame((state, delta) => {
                if (!gunRef.current) return;
                
                const time = state.clock.getElapsedTime();
                const swayX = Math.cos(time * 4) * 0.02;
                const swayY = Math.sin(time * 4) * 0.02;
                
                if (recoil > 0) {
                    setRecoil(r => Math.max(0, r - delta * 2));
                }

                gunRef.current.position.copy(camera.position);
                gunRef.current.quaternion.copy(camera.quaternion);
                
                gunRef.current.translateX(0.5);
                gunRef.current.translateY(-0.4 + swayY);
                gunRef.current.translateZ(-0.6 + recoil + swayX);

                if (flashRef.current) {
                    flashRef.current.visible = recoil > 0.15;
                    flashRef.current.rotation.z = Math.random() * Math.PI;
                }
            });

            return (
                <group ref={gunRef}>
                    <mesh castShadow>
                        <boxGeometry args={[0.2, 0.2, 0.8]} />
                        <meshStandardMaterial color="#334155" roughness={0.5} metalness={0.8} />
                    </mesh>
                    <mesh position={[0, 0, -0.45]}>
                        <boxGeometry args={[0.12, 0.12, 0.2]} />
                        <meshStandardMaterial color="#0f172a" />
                    </mesh>
                    <mesh position={[0, 0.1, -0.2]}>
                        <boxGeometry args={[0.05, 0.02, 0.4]} />
                        <meshBasicMaterial color="#00ffff" />
                    </mesh>
                    <mesh ref={flashRef} position={[0, 0, -0.6]}>
                        <planeGeometry args={[0.8, 0.8]} />
                        <meshBasicMaterial color="#00ffff" transparent opacity={0.8} />
                    </mesh>
                </group>
            );
        };

        const ParticleRenderer = ({ particle }) => {
            const meshRef = useRef(null);
            useFrame((state, delta) => {
                if (meshRef.current) {
                    meshRef.current.position.add(particle.velocity.clone().multiplyScalar(delta));
                    const age = Date.now() - particle.createdAt;
                    const lifeRatio = 1 - (age / particle.life);
                    
                    meshRef.current.scale.setScalar(particle.size * lifeRatio);
                    
                    if (meshRef.current.material) {
                        meshRef.current.material.opacity = lifeRatio;
                    }
                }
            });
            return (
                <mesh ref={meshRef} position={particle.position}>
                    <dodecahedronGeometry args={[1, 0]} />
                    <meshBasicMaterial color={particle.color} transparent />
                </mesh>
            );
        };

        const EnemyRenderer = ({ enemy }) => {
            const groupRef = useRef(null);
            const materialRef = useRef(null);
            
            useFrame((state, delta) => {
                if (!groupRef.current) return;
                groupRef.current.position.lerp(enemy.position, 0.2);
                groupRef.current.rotation.z += 0.05;
                groupRef.current.rotation.x += 0.02;

                if (materialRef.current) {
                    if (enemy.hitFlash > 0) {
                        materialRef.current.emissive.setHex(0xffffff);
                        materialRef.current.emissiveIntensity = 1;
                        enemy.hitFlash -= delta;
                    } else {
                        materialRef.current.emissive.setHex(0x000000);
                        materialRef.current.emissiveIntensity = 0;
                    }
                }
            });

            return (
                <group ref={groupRef} position={enemy.position}>
                    <mesh castShadow receiveShadow>
                        <octahedronGeometry args={[enemy.type === 'tank' ? 2 : 1, 0]} />
                        <meshStandardMaterial ref={materialRef} color={enemy.color} roughness={0.2} metalness={0.8} />
                    </mesh>
                    <mesh>
                        <octahedronGeometry args={[enemy.type === 'tank' ? 2.2 : 1.2, 0]} />
                        <meshBasicMaterial color={enemy.color} wireframe transparent opacity={0.3} />
                    </mesh>
                    <group position={[0, enemy.type === 'tank' ? 2.5 : 1.5, 0]}>
                        <mesh scale-x={Math.max(0, enemy.hp / enemy.maxHp)}>
                        <planeGeometry args={[2, 0.2]} />
                        <meshBasicMaterial color="#ef4444" />
                        </mesh>
                    </group>
                </group>
            );
        };

        const BulletRenderer = ({ bullet }) => {
            const meshRef = useRef(null);
            useFrame(() => {
                if (meshRef.current) {
                    meshRef.current.position.copy(bullet.position);
                    meshRef.current.scale.z = 8;
                }
            });
            return (
                <mesh ref={meshRef} position={bullet.position}>
                    <cylinderGeometry args={[0.05, 0.05, 1, 8]} rotation={[Math.PI / 2, 0, 0]} />
                    <meshBasicMaterial color={COLORS.bullet} toneMapped={false} />
                </mesh>
            );
        };

        const StarField = () => {
            const starsRef = useRef(null);
            
            useFrame((state, delta) => {
                if (!starsRef.current) return;
                const positions = starsRef.current.geometry.attributes.position.array;
                
                for(let i = 0; i < positions.length; i+=3) {
                    positions[i+2] += 40 * delta; 
                    if (positions[i+2] > 20) {
                        positions[i+2] = -100;
                        positions[i] = (Math.random() - 0.5) * 100;
                        positions[i+1] = (Math.random() - 0.5) * 60;
                    }
                }
                starsRef.current.geometry.attributes.position.needsUpdate = true;
            });

            const starGeo = useMemo(() => {
                const geo = new THREE.BufferGeometry();
                const count = 1000;
                const pos = new Float32Array(count * 3);
                for(let i=0; i<count*3; i+=3) {
                    pos[i] = (Math.random() - 0.5) * 100;
                    pos[i+1] = (Math.random() - 0.5) * 60;
                    pos[i+2] = (Math.random() - 0.5) * 120;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                return geo;
            }, []);

            return (
                <points ref={starsRef}>
                    <bufferGeometry attach="geometry" {...starGeo} />
                    <pointsMaterial size={0.2} color="white" transparent opacity={0.8} />
                </points>
            );
        };

        function GameScene({ onGameOver, setScore, setHealth, setWave, health, isMenuMode = false }) {
            const { camera } = useThree();
            
            const gameState = useRef({
                enemies: [],
                bullets: [],
                particles: [],
                score: 0,
                wave: 1,
                player: {
                    position: new THREE.Vector3(0, 5, 0),
                    velocity: new THREE.Vector3(),
                    targetTilt: 0,
                    nextShotTime: 0,
                    nextSpawnTime: 0,
                    startTime: Date.now(),
                    lastShot: 0,
                },
                keys: {}
            });

            const [renderTrigger, setRenderTrigger] = useState(0);

            useEffect(() => {
                if (isMenuMode) return;

                const handleKeyDown = (e) => { gameState.current.keys[e.code] = true; };
                const handleKeyUp = (e) => { gameState.current.keys[e.code] = false; };
                const handleMouseDown = () => { gameState.current.keys['MouseLeft'] = true; };
                const handleMouseUp = () => { gameState.current.keys['MouseLeft'] = false; };
                
                const handleMouseMove = (e) => {
                    if (document.pointerLockElement === document.querySelector('canvas')) {
                        const sens = PLAYER_SENSITIVITY;
                        const p = gameState.current.player.position;
                        
                        p.x += e.movementX * sens;
                        p.y -= e.movementY * sens; 

                        p.x = Math.max(-PLAYER_MAX_X, Math.min(PLAYER_MAX_X, p.x));
                        p.y = Math.max(PLAYER_MIN_Y, Math.min(PLAYER_MAX_Y, p.y));

                        gameState.current.player.targetTilt = -e.movementX * 0.05;
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                window.addEventListener('mousedown', handleMouseDown);
                window.addEventListener('mouseup', handleMouseUp);
                window.addEventListener('mousemove', handleMouseMove);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                    window.removeEventListener('mousedown', handleMouseDown);
                    window.removeEventListener('mouseup', handleMouseUp);
                    window.removeEventListener('mousemove', handleMouseMove);
                };
            }, [isMenuMode]);

            useEffect(() => {
                if (isMenuMode) {
                    camera.position.set(0, 5, 20);
                    camera.lookAt(0, 5, 0);
                } else {
                    camera.position.set(0, 5, 0);
                    camera.rotation.set(0, 0, 0);
                }
            }, [isMenuMode, camera]);


            useFrame((state, delta) => {
                const game = gameState.current;
                
                if (isMenuMode) {
                    camera.position.x = Math.sin(state.clock.getElapsedTime() * 0.5) * 10;
                    camera.lookAt(0, 5, 0);
                    return;
                }

                if (health <= 0) return;

                const now = Date.now();
                let needsRender = false;

                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, game.player.targetTilt, 0.1);
                game.player.targetTilt = THREE.MathUtils.lerp(game.player.targetTilt, 0, 0.1);
                
                camera.position.lerp(game.player.position, 0.5);
                
                if (game.keys['MouseLeft'] && now >= game.player.nextShotTime) {
                    game.player.nextShotTime = now + 120;
                    game.player.lastShot = now;
                    
                    playSound('shoot');

                    const spawnPos = game.player.position.clone();
                    spawnPos.y -= 0.5;
                    
                    game.bullets.push({
                        id: Math.random().toString(),
                        position: spawnPos,
                        velocity: new THREE.Vector3(0, 0, -BULLET_SPEED),
                        createdAt: now
                    });
                    needsRender = true;
                    
                    camera.position.z += 0.4;
                }
                camera.position.z = THREE.MathUtils.lerp(camera.position.z, 0, 0.1);

                for (let i = game.bullets.length - 1; i >= 0; i--) {
                    const b = game.bullets[i];
                    b.position.add(b.velocity.clone().multiplyScalar(delta));

                    if (now - b.createdAt > BULLET_LIFETIME || b.position.z < -ARENA_SIZE - 20) {
                        game.bullets.splice(i, 1);
                        needsRender = true;
                    }
                }

                for (let i = game.particles.length - 1; i >= 0; i--) {
                    const p = game.particles[i];
                    p.position.add(p.velocity.clone().multiplyScalar(delta));
                    if (now - p.createdAt > p.life) {
                        game.particles.splice(i, 1);
                        needsRender = true;
                    }
                }

                const timeSinceStart = now - game.player.startTime;
                const spawnRate = Math.max(800, ENEMY_SPAWN_RATE_BASE - (timeSinceStart / 20)); 
                
                if (now > game.player.nextSpawnTime) {
                    game.player.nextSpawnTime = now + spawnRate;
                    
                    const currentWave = Math.floor(timeSinceStart / 20000) + 1;
                    if (currentWave !== game.wave) {
                        game.wave = currentWave;
                        setWave(currentWave);
                    }

                    spawnEnemy(currentWave);
                    needsRender = true;
                }

                let damageTaken = 0;
                
                for (let i = game.enemies.length - 1; i >= 0; i--) {
                    const e = game.enemies[i];
                    
                    e.position.z += e.speed * delta;
                    
                    const vectorToPlayer = new THREE.Vector3().subVectors(game.player.position, e.position);
                    e.position.x += vectorToPlayer.x * 0.2 * delta; 
                    e.position.y += vectorToPlayer.y * 0.2 * delta;

                    if (e.position.z > 5) {
                        game.enemies.splice(i, 1);
                        needsRender = true;
                        continue;
                    }

                    const distToPlayer = e.position.distanceTo(game.player.position);
                    if (distToPlayer < 2.5) {
                        damageTaken += 15;
                        spawnExplosion(e.position, e.color, 15);
                        playSound('explode');
                        
                        game.enemies.splice(i, 1);
                        needsRender = true;
                        
                        camera.position.x += (Math.random() - 0.5) * 2;
                        camera.position.y += (Math.random() - 0.5) * 2;
                        continue;
                    }

                    for (let j = game.bullets.length - 1; j >= 0; j--) {
                        const b = game.bullets[j];
                        if (b.position.distanceTo(e.position) < (e.type === 'tank' ? 3 : 2)) {
                            e.hp -= 10;
                            e.hitFlash = 0.1;
                            
                            playSound('hit');
                            
                            game.bullets.splice(j, 1);
                            needsRender = true;

                            if (e.hp <= 0) {
                                game.enemies.splice(i, 1);
                                game.score += (e.type === 'tank' ? 50 : e.type === 'fast' ? 20 : 10);
                                setScore(game.score);
                                needsRender = true;
                                
                                playSound('explode');
                                spawnExplosion(e.position, e.color, 10);
                            }
                            break;
                        }
                    }
                }

                if (damageTaken > 0) {
                    setHealth(prev => {
                        const nh = prev - damageTaken;
                        if (nh <= 0) onGameOver(game.score);
                        return nh;
                    });
                }

                if (needsRender || game.particles.length > 0) setRenderTrigger(p => p + 1);
            });

            const spawnEnemy = (wave) => {
                const spawnZ = -ARENA_SIZE;
                const spawnX = (Math.random() - 0.5) * PLAYER_MAX_X * 2.5;
                const spawnY = Math.random() * PLAYER_MAX_Y + 1;
                
                const typeRoll = Math.random();
                let type = 'basic';
                let speed = 8 + (wave * 0.5);
                let hp = 10 + (wave * 2);
                let color = COLORS.enemyBasic;

                if (wave > 2 && typeRoll > 0.8) {
                    type = 'fast';
                    speed *= 1.3;
                    hp *= 0.6;
                    color = COLORS.enemyFast;
                } else if (wave > 4 && typeRoll > 0.95) {
                    type = 'tank';
                    speed *= 0.6;
                    hp *= 4;
                    color = COLORS.enemyTank;
                }

                gameState.current.enemies.push({
                    id: Math.random().toString(),
                    position: new THREE.Vector3(spawnX, spawnY, spawnZ),
                    speed,
                    hp,
                    maxHp: hp,
                    color,
                    type,
                    hitFlash: 0
                });
            };

            const spawnExplosion = (pos, color, count) => {
                for (let i=0; i<count; i++) {
                    const vel = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );
                    gameState.current.particles.push({
                        id: Math.random().toString(),
                        position: pos.clone(),
                        velocity: vel,
                        color: color,
                        createdAt: Date.now(),
                        life: 500 + Math.random() * 500,
                        size: 0.5 + Math.random() * 0.5
                    });
                }
            };

            return (
                <group>
                    <ambientLight intensity={0.4} />
                    <pointLight position={[10, 10, 10]} intensity={1} />
                    <directionalLight position={[0, 10, 5]} intensity={1} castShadow />

                    <StarField />
                    
                    {gameState.current.enemies.map(e => (
                        <EnemyRenderer key={e.id} enemy={e} />
                    ))}

                    {gameState.current.bullets.map(b => (
                        <BulletRenderer key={b.id} bullet={b} />
                    ))}

                    {gameState.current.particles.map(p => (
                        <ParticleRenderer key={p.id} particle={p} />
                    ))}

                    {!isMenuMode && <PlayerWeapon lastShot={gameState.current.player.lastShot} />}
                </group>
            );
        }

        // --- APP ROOT ---

        function App() {
            const [gameState, setGameState] = useState('start');
            const [score, setScore] = useState(0);
            const [health, setHealth] = useState(100);
            const [wave, setWave] = useState(1);
            
            const startGame = () => {
                setScore(0);
                setHealth(100);
                setWave(1);
                setGameState('playing');
                
                const canvas = document.querySelector('canvas');
                if (canvas) {
                    canvas.requestPointerLock();
                }
            };

            const handleGameOver = useCallback((finalScore) => {
                setGameState('gameover');
                setScore(finalScore);
                document.exitPointerLock();
            }, []);

            return (
                <div className="relative w-full h-full select-none font-sans">
                    <Canvas shadows camera={{ fov: 80, position: [0, 5, 10] }}>
                        <color attach="background" args={['#0f172a']} />
                        
                        {gameState === 'playing' && (
                            <GameScene
                                onGameOver={handleGameOver}
                                setScore={setScore}
                                setHealth={setHealth}
                                setWave={setWave}
                                health={health}
                            />
                        )}
                        
                        {gameState !== 'playing' && (
                           <GameScene 
                             onGameOver={() => {}} 
                             setScore={() => {}} 
                             setHealth={() => {}} 
                             setWave={() => {}} 
                             health={100}
                             isMenuMode={true} 
                           />
                        )}
                    </Canvas>

                    <div id="game-overlay" className="absolute inset-0 pointer-events-none">
                        
                        {gameState === 'playing' && (
                            <div className="absolute inset-0 p-6 flex flex-col justify-between">
                                <div className="flex justify-between items-start">
                                    <div className="bg-black/50 text-white p-4 rounded-xl backdrop-blur-sm border border-white/20">
                                        <div className="text-sm uppercase tracking-wider text-gray-300">Score</div>
                                        <div className="text-3xl font-bold font-mono text-yellow-400">{score.toLocaleString()}</div>
                                    </div>
                                    
                                    <div className="bg-black/50 text-white p-4 rounded-xl backdrop-blur-sm border border-white/20 text-right">
                                        <div className="text-sm uppercase tracking-wider text-gray-300">Wave</div>
                                        <div className="text-3xl font-bold font-mono text-purple-400">{wave}</div>
                                    </div>
                                </div>

                                <div className="flex justify-start items-end">
                                   <div className="w-64">
                                        <div className="flex justify-between text-white mb-2 font-bold text-lg shadow-black drop-shadow-md">
                                            <span>SHIELD</span>
                                            <span>{Math.max(0, Math.round(health))}%</span>
                                        </div>
                                        <div className="h-6 w-full bg-gray-800 rounded-full border-2 border-white/30 overflow-hidden relative">
                                            <div 
                                                className={`h-full transition-all duration-300 ${health > 30 ? 'bg-cyan-500' : 'bg-red-500'}`}
                                                style={{ width: `${Math.min(100, Math.max(0, health))}%` }}
                                            />
                                        </div>
                                   </div>
                                </div>

                                <div className="crosshair z-50 mix-blend-screen opacity-80" />
                                
                                <div 
                                    className="absolute inset-0 pointer-events-none transition-opacity duration-300 bg-red-600 mix-blend-overlay"
                                    style={{ opacity: Math.max(0, (100 - health) / 200) }} 
                                />
                            </div>
                        )}

                        {gameState === 'start' && (
                            <div className="absolute inset-0 flex items-center justify-center bg-black/60 pointer-events-auto backdrop-blur-sm">
                                <div className="bg-white p-8 rounded-3xl shadow-2xl text-center max-w-md border-4 border-cyan-500 transform transition-all hover:scale-105">
                                    <h1 className="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-500 to-blue-600 mb-2 drop-shadow-sm">
                                        HYPER WING
                                    </h1>
                                    <p className="text-gray-500 font-bold mb-8 text-lg">DEFEND THE SECTOR</p>
                                    
                                    <div className="space-y-4 text-left text-gray-700 bg-gray-100 p-4 rounded-xl mb-8">
                                        <div className="flex items-center gap-3">
                                            <div className="bg-white border-b-2 border-gray-300 px-3 py-1 rounded font-mono font-bold">MOUSE</div>
                                            <span>to Fly Up/Down/Left/Right</span>
                                        </div>
                                        <div className="flex items-center gap-3">
                                            <div className="bg-white border-b-2 border-gray-300 px-3 py-1 rounded font-mono font-bold">CLICK</div>
                                            <span>to Shoot</span>
                                        </div>
                                    </div>

                                    <button 
                                        onClick={startGame}
                                        className="w-full py-4 bg-green-500 hover:bg-green-600 text-white font-black text-2xl rounded-xl shadow-[0_4px_0_rgb(21,128,61)] hover:shadow-[0_2px_0_rgb(21,128,61)] hover:translate-y-[2px] transition-all"
                                    >
                                        LAUNCH
                                    </button>
                                </div>
                            </div>
                        )}

                        {gameState === 'gameover' && (
                            <div className="absolute inset-0 flex items-center justify-center bg-red-900/80 pointer-events-auto backdrop-blur-md">
                                <div className="bg-white p-8 rounded-3xl shadow-2xl text-center max-w-md border-4 border-red-500 animate-bounce-short">
                                    <h1 className="text-6xl font-black text-red-600 mb-2">DESTROYED</h1>
                                    <p className="text-gray-600 font-bold mb-6 text-xl">System Failure</p>
                                    
                                    <div className="bg-gray-100 rounded-xl p-6 mb-8">
                                        <div className="text-gray-500 uppercase text-sm font-bold tracking-widest">Final Score</div>
                                        <div className="text-5xl font-black text-gray-800">{score.toLocaleString()}</div>
                                    </div>

                                    <button 
                                        onClick={startGame}
                                        className="w-full py-4 bg-blue-500 hover:bg-blue-600 text-white font-black text-2xl rounded-xl shadow-[0_4px_0_rgb(29,78,216)] hover:shadow-[0_2px_0_rgb(29,78,216)] hover:translate-y-[2px] transition-all"
                                    >
                                        REBOOT
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
